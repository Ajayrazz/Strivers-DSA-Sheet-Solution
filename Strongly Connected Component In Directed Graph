class Solution {
    // Function to find number of strongly connected components in the graph.
    public int kosaraju(ArrayList<ArrayList<Integer>> adj) {
        // code here
        int V = adj.size();
        boolean[] visited = new boolean[V];
        Stack<Integer> stack = new Stack<>();
        
        //apply topological sorting
        for(int i = 0; i < V; i++){
            if(!visited[i]){
                topoSort(i, adj, visited, stack);
            }
        }
        
        ArrayList<ArrayList<Integer>> adjT = new ArrayList<>();
        for(int i = 0; i < V; i++){
            adjT.add(new ArrayList<>());
        }
        
        for(int i = 0; i < V; i++){
            //un-visit
            visited[i] = false;
            for(Integer it : adj.get(i)){
                adjT.get(it).add(i);
            }
        }
        
        int scc = 0;
        while(!stack.isEmpty()){
            int node = stack.pop();
            if(!visited[node]){
                scc++;
                //apply depth first search
                dfs(node, adjT, visited);
            }
        }
        
        return scc;
    }
    
    //Topological Sorting Function
    public void topoSort(int node, ArrayList<ArrayList<Integer>> adj, boolean[] visited, Stack<Integer> stack){
        //visit
        visited[node] = true;
        for(int adjNode : adj.get(node)){
            if(!visited[adjNode]){
                topoSort(adjNode, adj, visited, stack);
            }
        }
        
        stack.push(node);
    }
    
    //Depth First Search Function
    public void dfs(int node, ArrayList<ArrayList<Integer>> adjT, boolean[] visited){
        //visit
        visited[node] = true;
        for(int adjNode : adjT.get(node)){
            if(!visited[adjNode]){
                dfs(adjNode, adjT, visited);
            }
        }
    }
}
