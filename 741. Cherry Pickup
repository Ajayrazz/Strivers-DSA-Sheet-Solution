class Solution {
    private static final int NEG = -1000000000;
    public int cherryPickup(int[][] grid) {
        int n = grid.length;
        int[][][] dp = new int[n][n][n];
        for (int[][] layer : dp){
            for (int[] row : layer){
                Arrays.fill(row, Integer.MIN_VALUE);
            }
        }
        int ans = solve(grid, dp, 0, 0, 0);
        return Math.max(0, ans);
    }

    private int solve(int[][] grid, int[][][] dp, int r1, int c1, int c2) {
        int n = grid.length;
        int r2 = r1 + c1 - c2;
        // Invalid state
        if (r1 >= n || c1 >= n || r2 >= n || c2 >= n) return NEG;
        if (grid[r1][c1] == -1 || grid[r2][c2] == -1) return NEG;
        // Base case
        if (r1 == n - 1 && c1 == n - 1) return grid[r1][c1];

        if (dp[r1][c1][c2] != Integer.MIN_VALUE) return dp[r1][c1][c2];

        // Collect cherries
        int cherries = grid[r1][c1];
        if (r1 != r2) cherries += grid[r2][c2];

        // 4 movement combinations
        int next = Math.max(
                Math.max(solve(grid, dp, r1 + 1, c1, c2),      // down, down
                         solve(grid, dp, r1, c1 + 1, c2)),     // right, down
                Math.max(solve(grid, dp, r1 + 1, c1, c2 + 1),  // down, right
                         solve(grid, dp, r1, c1 + 1, c2 + 1))  // right, right
        );

        //update dp
        return dp[r1][c1][c2] = (next == NEG) ? NEG : cherries + next;
    }
}
