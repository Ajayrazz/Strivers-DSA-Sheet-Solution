class Solution {
    public int minCost(int[][] grid, int k) {
        int rows = grid.length, cols = grid[0].length;

        List<int[]> cells = new ArrayList<>();
        for (int r = 0; r < rows; r++)
            for (int c = 0; c < cols; c++)
                cells.add(new int[]{r, c});

        cells.sort((a, b) -> grid[a[0]][a[1]] - grid[b[0]][b[1]]);

        int[][] dp = new int[rows][cols];
        for (int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);

        for (int step = 0; step <= k; step++) {
            int currentMin = Integer.MAX_VALUE;

            for (int i = 0, start = 0; i < cells.size(); i++) {
                int r = cells.get(i)[0], c = cells.get(i)[1];
                currentMin = Math.min(currentMin, dp[r][c]);

                if (i + 1 < cells.size() &&
                    grid[r][c] == grid[cells.get(i + 1)[0]][cells.get(i + 1)[1]])
                    continue;

                while (start <= i) {
                    int x = cells.get(start)[0], y = cells.get(start)[1];
                    dp[x][y] = currentMin;
                    start++;
                }
            }

            for (int r = rows - 1; r >= 0; r--) {
                for (int c = cols - 1; c >= 0; c--) {
                    if (r == rows - 1 && c == cols - 1) {
                        dp[r][c] = 0;
                        continue;
                    }
                    if (r + 1 < rows)
                        dp[r][c] = Math.min(dp[r][c], dp[r + 1][c] + grid[r + 1][c]);
                    if (c + 1 < cols)
                        dp[r][c] = Math.min(dp[r][c], dp[r][c + 1] + grid[r][c + 1]);
                }
            }
        }
        return dp[0][0];
    }
}
