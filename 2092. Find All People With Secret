class Solution {
    public List<Integer> findAllPeople(int totalPeople, int[][] meetingList, int initialReceiver) {
        Map<Integer, List<int[]>> adjacencyMap = new HashMap<>();

        for (int[] meeting : meetingList) {
            int a = meeting[0];
            int b = meeting[1];
            int time = meeting[2];

            adjacencyMap.computeIfAbsent(a, k -> new ArrayList<>())
                        .add(new int[]{time, b});
            adjacencyMap.computeIfAbsent(b, k -> new ArrayList<>())
                        .add(new int[]{time, a});
        }

        int[] earliestTimeKnown = new int[totalPeople];
        Arrays.fill(earliestTimeKnown, Integer.MAX_VALUE);

        PriorityQueue<int[]> minHeap =
            new PriorityQueue<>((x, y) -> x[1] - y[1]);

        earliestTimeKnown[0] = 0;
        earliestTimeKnown[initialReceiver] = 0;

        minHeap.offer(new int[]{0, 0});
        minHeap.offer(new int[]{initialReceiver, 0});

        while (!minHeap.isEmpty()) {
            int[] current = minHeap.poll();
            int person = current[0];
            int time = current[1];

            if (time > earliestTimeKnown[person]) continue;

            for (int[] next : adjacencyMap.getOrDefault(person, new ArrayList<>())) {
                int meetingTime = next[0];
                int nextPerson = next[1];

                if (meetingTime >= time &&
                    earliestTimeKnown[nextPerson] > meetingTime) {

                    earliestTimeKnown[nextPerson] = meetingTime;
                    minHeap.offer(new int[]{nextPerson, meetingTime});
                }
            }
        }

        List<Integer> result = new ArrayList<>();
        for (int i = 0; i < totalPeople; i++) {
            if (earliestTimeKnown[i] != Integer.MAX_VALUE) {
                result.add(i);
            }
        }

        return result;
    }
}
